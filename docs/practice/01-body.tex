\chapter{Технологический раздел}

\section{IDEF0-диаграмма разрабатываемого метода}

На рисунке ниже представлена диаграмма IDEF0 метода резервного копирования.

\imgw{idef00schema}{h!}{1.0\textwidth}{IDEF0--диаграмма уровня A0}

\begin{flushleft}
На вход метода подаются:
\end{flushleft}
\begin{itemize}[label=\textbullet]
\item место хранения суперблоков - расположение директорий в ФС;
\item место хранения блоков файлов - расположение директории в ФС;
\item файлы, для которых делается резервная копия.
\end{itemize}

Выходными данными являются резервные копии файлов (суперблоки).  

Механизмы, используемые методом --- файловая система (ФС) и хранилища данных (директории для хранения).  

\section{Выбор инструментов и технологий}

\subsection{Язык программирования}

В качестве языка программирования для разработки  было решено использовать язык Golang \cite{golang}. К преимуществам данного языка можно отнести статическую типизацию, компилируемость, большое
разнообразие библиотек для документирования, тестирования и создания интерфейсов.

\begin{flushleft}
Статическая типизация обеспечивает:
\end{flushleft}
\begin{itemize}[label=\textbullet]
\item Надежность и безопасность --- cтатическая типизация позволяет обнаруживать ошибки во время компиляции, такие как несоответствие типов, отсутствие ожидаемых методов и неправильное использование переменных. Это помогает предотвратить множество ошибок времени выполнения и повысить надежность и безопасность программы.

\item Читаемость и поддержку кода --- статическая типизация делает код более читаемым и понятным, поскольку типы переменных и функций указывают на их предназначение и взаимодействие. Кроме того, статическая типизация облегчает сопровождение кода, поскольку компилятор и инструменты разработчика могут предоставлять более точные подсказки и автодополнение кода.
\end{itemize}

%Это означает, что программы, написанные на Golang, могут быть переносимыми, то есть выполняться на различных операционных системах, таких как Windows \cite{windows}, macOS \cite{macos} и Linux \cite{linux}, а также на других платформах.
%
%Компилятор Golang преобразует код на Golang в исполняемые файлы, специфичные для конкретной операционной системы и архитектуры процессора. Это позволяет выполнять приложение на Golang на разных платформах без необходимости изменения исходного кода.

Golang обладает малым размером исполняемых файлов и низким потреблением памяти. Это особенно важно для метода резервного копирования, где требуется обработка больших объемов данных. Go позволяет эффективно использовать ресурсы, что обеспечивает более быструю и эффективную обработку данных при резервном копировании.

\subsection{Интерфейс приложения}

Приложение будет представлять из себя консольную утилиту (CLI) \cite{cli}.

Для этого будет использоваться библиотека cobra \cite{cobra}, которая предоставляет:
\begin{enumerate}
\item механизмы обработки ошибок и валидации пользовательского ввода;
\item API для создания команд и флагов;
\item предоставляет встроенную поддержку генерации справки по командам и флагам;
\item обеспечивает поддержку для тестирования.
\end{enumerate}

\begin{flushleft}
Такой интерфейс имеет ряд преимуществ:
\end{flushleft}

\begin{itemize}[label=\textbullet]
\item CLI обеспечивает легкость в автоматизации и скриптовании операций резервного копирования. Пользователь может создавать скрипты или автоматические задачи для выполнения резервного копирования по расписанию (cron \cite{cron}) или на основе определенных событий.

\item CLI-интерфейсы более гибкие и переносимые, поскольку они не привязаны к конкретной операционной системе или графической библиотеке.

\end{itemize}

Выбор CLI для метода резервного копирования обеспечивает возможность автоматизации, высокую производительность, гибкость и переносимость.
\newpage

\section{Реализация метода}

Рассмотрим реализации алгоритмов, описанных в конструкторском разделе. 

\subsection{Создание блоков}
Проверяем, если директория пустая, то завершаем алгоритм, иначе - начинаем обработку каждого файла.  

\listingfile{add.go}{cli-add-command-1}{go}{Алгоритм создания блоков. Часть 1.}{linerange={1-20}}
\newpage

Считываем файл, затем делим его на блоки размера $blockSize$. 
Размер блока определяется функцией $calculateBlockSize$.  
\begin{lstlisting}[
language=go, 
caption={Алгоритм определения размера блока}, frame=single
]
func calculateBlockSize(fileSize int64, numBlocks int) int64 {
	return int64(RoundUpToNearestMultiple(int(fileSize), numBlocks) / numBlocks)
}

func RoundUpToNearestMultiple(n, k int) int {
	return ((n + k - 1) / k) * k
}
\end{lstlisting}

Для вычисления размера блока используется алгоритм округления вверх до ближайшего кратного.

Находится такое число $X$, которое больше числа $N$ и кратно ему, но при этом минимально. В данном случае $N$ ---  размер файла, $k$ --- количество серверов. 

Такое вычисление размера позволяет гарантировать, что последний блок всегда будет меньше остальных. При создании суперблока это позволяет дописывать нули в конец последнего блока , чтобы размер блоков был одинаковый. 

Затем считается чек-сумма, сохраняются блоки и информация о них в конфигурационный файл. 

\listingfile{add.go}{cli-add-command-2}{go}{Алгоритм создания блоков. Часть 2.}{linerange={21-29}}
\newpage
\listingfile{add.go}{cli-add-command-3}{go}{Алгоритм создания блоков. Часть 3.}{linerange={30-65}}
\newpage

\listingfile{add.go}{cli-add-command-4
}{go}{Алгоритм создания блоков. Часть 4.}{linerange={66-88}}
\newpage
\subsection{Создание и восстановление суперблока}
Для создания суперблока проходим по всем файлам из конфигурационного файла, выбираем сервер для сохранения суперблока, создаем суперблок при помощи XOR блоков, добавляя нули в конец последнего блока, затем сохраняем информацию о суперблоке в конфиг, а сам суперблок на сервер.   

\listingfile{backup.go}{cli-backup-command-1
}{go}{Алгоритм создания и восстановления суперблока. Часть 1.}{linerange={1-26}}
\newpage
\listingfile{backup.go}{cli-backup-command-2
}{go}{Алгоритм создания и восстановления суперблока. Часть 2.}{linerange={27-40}}

Функция для создания суперблока через XOR его блоков. Для последнего блока добавляются нули, выравнивающие размер блока.

\listingfile{backup.go}{cli-backup-xor-command-1
}{go}{Функция создания суперблока через XOR. Часть 1.}{linerange={42-59}}
\newpage
\listingfile{backup.go}{cli-backup-xor-command-2
}{go}{Функция создания суперблока через XOR. Часть 2.}{linerange={60-78}}
\newpage
\subsection{Восстановление файла}
Для восстановления файла нужна информация о нем и о суперблоки. Такая информация берется из конфигурационного файла, после чего начинается процесс восстановления --- выполняется обратный XOR с удаланием избыточных нулей из последнего блока.  

\listingfile{restore.go}{cli-backup-restore-command-1
}{go}{Алгоритм восстановления файла. Часть 1.}{linerange={14-36}}

\newpage
\listingfile{restore.go}{cli-backup-restore-command-2
}{go}{Алгоритм восстановления файла. Часть 2.}{linerange={37-58}}
\newpage
\section{Пример использования разработанного метода}

Рассмотрим сценарий использования. 

\begin{flushleft}
В директории есть несколько файлов: 
\end{flushleft}
\begin{itemize}
\item 1 текстовый файл;
\item 3 картинки;
\item 1 видеозапись.
\end{itemize}

\imgw{demo-src-files}{h!}{1.0\textwidth}{Исходные файлы для создания резервной копии}
\newpage
Далее соберем и воспользуемся программой.  
При запуске без команд выводится справка.

\imgw{demo-build-cli}{h!}{1.0\textwidth}{Сборка программы и вывод справки}

Первым шагом нужно разбить файлы на блоки.  
Для этого вызовем команду \textit{backupcli add --dir=./src}

\imgw{demo-command-add}{h!}{1.0\textwidth}{Команда add}
\newpage

В результате выполнения команды в папку \textit{./blocks} были сохранены блоки, на которые были поделены исходные файлы. Каждый файл разбился на 3 блока --- по количеству доступных серверов.  

\imgw{demo-file-blocks}{h!}{1.0\textwidth}{Файлы, разбитые на блоки}

\newpage
Далее вызовем команду \textit{backupcli backup}, которая создаст резервные копии для файлов и распределит их по серверам.  

\imgw{demo-command-backup}{h!}{1.0\textwidth}{Файлы, разбитые на блоки}
Получившиеся суперблоки распределяются по серверам по алгоритму Round-Robin.  

\imgw{demo-superblocks}{h!}{1.0\textwidth}{Суперблоки, распределенные по серверам}
\newpage

Проверим целостность файлов: являются файлы из директории \textit{/src} равными файлам, которые хранятся в виде суперблоков на серверах.

Для этого вызовем команду \textit{backupcli info}, которая посчитает чек-суммы исходных файлов и сравнит с теми, что хранятся в конфигурационном файле.  

\imgw{demo-command-info}{h!}{1.0\textwidth}{Команда info}

Поменяем один из файлов, для удобства сделаем это с текстовым файлом. 

\imgw{demo-update-file}{h!}{1.0\textwidth}{Изменение исходного файла}

\newpage
Вызовем \textit{backupcli info} и увидем, что исходный файл изменился, чек-суммы не сходятся.  

\imgw{demo-command-info-2}{h!}{1.0\textwidth}{Команда info, файлы не равны}

Восстановим этот файл - воспользуемся \textit{backupcli restore}.

\imgw{demo-command-restore}{h!}{1.0\textwidth}{Команда restore}

Посмотрим на diff исходного файла, который был изменен и восстановленного. 
\imgw{demo-files-diff}{h!}{1.0\textwidth}{Разница в исходном файле и восстановленном}

Восстановленный файл отличается от исходного одной строкой, которую мы ранее удалили для проверки восстановления.  

\newpage
Перепишем исходный файл восстановленным в папке \textit{./src} и снова проверим файлы на целостность.

\imgw{demo-command-info-3}{h!}{1.0\textwidth}{Команда info, файлы равны}


\section{Тестирование}

\begin{flushleft}
Тестирование метода производилось несколькими способами:
\end{flushleft}

\begin{itemize}[label=\textbullet]
\item юнит тестирование - покрыть основные функции тестами;
\item ручное тестирование.
\end{itemize}

\begin{flushleft}
Для ручного тестирования использовался следующий сценарий:
\end{flushleft}
\begin{enumerate}
\item  cоздать несколько тестовых файлов, которые будут использоваться в процессе резервного копирования;
\item создать резервные копии через команду \textit{backup};
\item восстановить файлы через команду \textit{restore};
\item проверить различия файлов (diff) визуально, или с использованием специальных программ, которые позовляют найти отличия в файлах.
\end{enumerate}

Для юнит тестирования будут использоваться встроенные в язык программирования инструменты.  

\section{Выводы}

\begin{flushleft}
В данном разделе:
\end{flushleft}
\begin{itemize}[label=\textbullet]
\item были выбраны средства реализации метода резервного копирования;
\item было разработано программное обеспечение, реализующее разработанный метод;
\item приведен пример использования разработанного метода;
\item осуществлено тестирование метода, для которого использовано два типа тестов --- юнит и ручные тесты.
\end{itemize}




