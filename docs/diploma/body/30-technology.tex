\chapter{Технологический раздел}

%\section{Выбор инструментов и технологий}

\section{Язык программирования}

В качестве языка программирования для разработки  было решено использовать язык Golang \cite{golang}. К преимуществам данного языка можно отнести статическую типизацию, компилируемость, большое
разнообразие библиотек для документирования, тестирования и создания интерфейсов.

\begin{flushleft}
Статическая типизация обеспечивает:
\end{flushleft}
\begin{itemize}
\item надежность и безопасность --- cтатическая типизация позволяет обнаруживать ошибки во время компиляции, такие как несоответствие типов, отсутствие ожидаемых методов и неправильное использование переменных, что помогает предотвратить множество ошибок времени выполнения и повысить надежность и безопасность программы.

\item читаемость и поддержку кода --- статическая типизация делает код более читаемым и понятным, поскольку типы переменных и функций указывают на их предназначение и взаимодействие, кроме того, статическая типизация облегчает сопровождение кода, поскольку компилятор и инструменты разработчика могут предоставлять более точные подсказки и автодополнение кода.
\end{itemize}

%Это означает, что программы, написанные на Golang, могут быть переносимыми, то есть выполняться на различных операционных системах, таких как Windows \cite{windows}, macOS \cite{macos} и Linux \cite{linux}, а также на других платформах.
%
%Компилятор Golang преобразует код на Golang в исполняемые файлы, специфичные для конкретной операционной системы и архитектуры процессора. Это позволяет выполнять приложение на Golang на разных платформах без необходимости изменения исходного кода.

Golang обладает малым размером исполняемых файлов и низким потреблением памяти. Это особенно важно для метода резервного копирования, где требуется обработка больших объемов данных. Go позволяет эффективно использовать ресурсы, что обеспечивает более быструю и эффективную обработку данных при резервном копировании.
\newpage
\section{Интерфейс приложения}

Приложение будет представлять из себя консольную утилиту (CLI) \cite{cli}.

Для этого будет использоваться библиотека cobra \cite{cobra}, которая предоставляет:
\begin{itemize}
\item механизмы обработки ошибок и валидации пользовательского ввода;
\item API для создания команд и флагов;
\item предоставляет встроенную поддержку генерации справки по командам и флагам;
\item обеспечивает поддержку для тестирования.
\end{itemize}

\begin{flushleft}
Такой интерфейс имеет ряд преимуществ.
\end{flushleft}

\begin{enumerate}
\item CLI обеспечивает легкость в автоматизации и скриптовании операций резервного копирования. Пользователь может создавать скрипты или автоматические задачи для выполнения резервного копирования по расписанию (cron \cite{cron}) или на основе определенных событий.

\item CLI-интерфейсы более гибкие и переносимые, поскольку они не привязаны к конкретной операционной системе или графической библиотеке.

\end{enumerate}

Выбор CLI для метода резервного копирования обеспечивает возможность автоматизации, высокую производительность, гибкость и переносимость.


Рассмотрим реализации алгоритмов, которые используются разработанным приложением.  

\newpage
\section{Создание блоков}
Проверяем, если директория пустая, то завершаем алгоритм, иначе - начинаем обработку каждого файла.  

\listingfile{add.go}{cli-add-command-1}{go}{Алгоритм создания блоков. Часть 1.}{linerange={1-20},numbers=none}
\newpage

Считываем файл, затем делим его на блоки размера $blockSize$. 
Размер блока определяется функцией $calculateBlockSize$.  
\begin{lstlisting}[
language=go, 
caption={Алгоритм определения размера блока}, frame=single,	numbers=none
]
func calculateBlockSize(fileSize int64, numBlocks int) int64 {
	return int64(RoundUpToNearestMultiple(int(fileSize), numBlocks) / numBlocks)
}

func RoundUpToNearestMultiple(n, k int) int {
	return ((n + k - 1) / k) * k
}
\end{lstlisting}

Для вычисления размера блока используется алгоритм округления вверх до ближайшего кратного.

Находится такое число $X$, которое больше числа $N$ и кратно ему, но при этом минимально. В данном случае $N$ ---  размер файла, $k$ --- количество серверов. 

Такое вычисление размера позволяет гарантировать, что последний блок всегда будет меньше остальных. При создании суперблока это позволяет дописывать нули в конец последнего блока , чтобы размер блоков был одинаковый. 

Затем считается чек-сумма, сохраняются блоки и информация о них в конфигурационный файл. 

\listingfile{add.go}{cli-add-command-2}{go}{Алгоритм создания блоков. Часть 2.}{linerange={21-29},	numbers=none}
\newpage
\listingfile{add.go}{cli-add-command-3}{go}{Алгоритм создания блоков. Часть 3.}{linerange={30-65},	numbers=none}
\newpage

\listingfile{add.go}{cli-add-command-4
}{go}{Алгоритм создания блоков. Часть 4.}{linerange={66-88},	numbers=none}
\newpage
\section{Создание и восстановление суперблока}
Для создания суперблока проходим по всем файлам из конфигурационного файла, выбираем сервер для сохранения суперблока, создаем суперблок при помощи XOR блоков, добавляя нули в конец последнего блока, затем сохраняем информацию о суперблоке в конфиг, а сам суперблок на сервер.   

\listingfile{backup.go}{cli-backup-command-1
}{go}{Алгоритм создания и восстановления суперблока. Часть 1.}{linerange={1-26},	numbers=none}
\newpage
\listingfile{backup.go}{cli-backup-command-2
}{go}{Алгоритм создания и восстановления суперблока. Часть 2.}{linerange={27-44},	numbers=none}

Функция для создания суперблока через XOR его блоков. Для последнего блока добавляются нули, выравнивающие размер блока.

\listingfile{backup.go}{cli-backup-xor-command-1
}{go}{Функция создания суперблока через XOR. Часть 1.}{linerange={46-59},	numbers=none}
\newpage
\listingfile{backup.go}{cli-backup-xor-command-2
}{go}{Функция создания суперблока через XOR. Часть 2.}{linerange={60-84},numbers=none}
\newpage
\section{Восстановление файла}
Для восстановления файла нужна информация о нем и о суперблоки. Такая информация берется из конфигурационного файла, после чего начинается процесс восстановления --- выполняется обратный XOR с удаланием избыточных нулей из последнего блока.  

\listingfile{restore.go}{cli-backup-restore-command-1
}{go}{Алгоритм восстановления файла. Часть 1.}{linerange={14-36},	numbers=none}

\newpage
\listingfile{restore.go}{cli-backup-restore-command-2
}{go}{Алгоритм восстановления файла. Часть 2.}{linerange={37-58},	numbers=none}
\newpage
\listingfile{restore.go}{cli-backup-restore-command-2
}{go}{Алгоритм восстановления файла. Часть 3.}{linerange={59-80},	numbers=none}
\newpage
\listingfile{restore.go}{cli-backup-restore-command-2
}{go}{Алгоритм восстановления файла. Часть 4.}{linerange={81-101},	numbers=none}
\newpage
\section{Пример использования разработанного метода}
\begin{flushleft}
CLI интерфейс имеет следующие команды:
\end{flushleft}
\begin{itemize}
\item \textit{add} --- деление файлов на блоки;
\item \textit{backup} --- создание резервных копий (суперблоков);
\item \textit{block-info} --- проверка целостности блоков;
\item \textit{files-info} --- проверка целостности файлов;
\item \textit{restore} --- восстановление блоков файла;
\item \textit{build} --- собрать файлы из блоков, восстановление файла.
\end{itemize}
Базовый сценарий использования предусматривает:
\begin{itemize}
\item добавление файлов и деление их на блоки --- \textit{backupcli add};
\item создание суперблоков --- \textit{backupcli backup};
\item восстановление блоков, например, если один блок был удален --- \textit{backupcli restore};
\item проверка целостности блоков до/после восстановления --- b\textit{ackupcli block-info};
\item восстановление файлов из блоков --- \textit{backupcli build};
\end{itemize}

Работа с программой следующим образом.
\newpage
\imgw{demo-add-backup-block-info}{h!}{1.0\textwidth}{Деление файлов на блоки, создание суперблоков и проверка целостности блоков}
\imgw{demo-restore-block-info-build}{h!}{1.0\textwidth}{Восстановелние блоков, проверка целостности и сборка файла}
\newpage
%\imgw{demo-src-files}{h!}{1.0\textwidth}{Исходные файлы для создания резервной копии}
%\newpage
%Далее соберем и воспользуемся программой.  
%При запуске без команд выводится справка.
%
%\imgw{demo-build-cli}{h!}{1.0\textwidth}{Сборка программы и вывод справки}
%
%Первым шагом нужно разбить файлы на блоки.  
%Для этого вызовем команду \textit{backupcli add --dir=./src}
%
%\imgw{demo-command-add}{h!}{1.0\textwidth}{Команда add}
%\newpage
%
%В результате выполнения команды в папку \textit{./blocks} были сохранены блоки, на которые были поделены исходные файлы. Каждый файл разбился на 3 блока --- по количеству доступных серверов.  
%
%\imgw{demo-file-blocks}{h!}{1.0\textwidth}{Файлы, разбитые на блоки}
%
%\newpage
%Далее вызовем команду \textit{backupcli backup}, которая создаст резервные копии для файлов и распределит их по серверам.  
%
%\imgw{demo-command-backup}{h!}{1.0\textwidth}{Файлы, разбитые на блоки}
%Получившиеся суперблоки распределяются по серверам по алгоритму Round-Robin.  
%
%\imgw{demo-superblocks}{h!}{1.0\textwidth}{Суперблоки, распределенные по серверам}
%\newpage
%
%Проверим целостность файлов: являются файлы из директории \textit{/src} равными файлам, которые хранятся в виде суперблоков на серверах.
%
%Для этого вызовем команду \textit{backupcli info}, которая посчитает чек-суммы исходных файлов и сравнит с теми, что хранятся в конфигурационном файле.  
%
%\imgw{demo-command-info}{h!}{1.0\textwidth}{Команда info}
%
%Поменяем один из файлов, для удобства сделаем это с текстовым файлом. 
%
%\imgw{demo-update-file}{h!}{1.0\textwidth}{Изменение исходного файла}
%
%\newpage
%Вызовем \textit{backupcli info} и увидем, что исходный файл изменился, чек-суммы не сходятся.  
%
%\imgw{demo-command-info-2}{h!}{1.0\textwidth}{Команда info, файлы не равны}
%
%Восстановим этот файл - воспользуемся \textit{backupcli restore}.
%
%\imgw{demo-command-restore}{h!}{1.0\textwidth}{Команда restore}
%
%Посмотрим на diff исходного файла, который был изменен и восстановленного. 
%\imgw{demo-files-diff}{h!}{1.0\textwidth}{Разница в исходном файле и восстановленном}
%
%Восстановленный файл отличается от исходного одной строкой, которую мы ранее удалили для проверки восстановления.  
%
%\newpage
%Перепишем исходный файл восстановленным в папке \textit{./src} и снова проверим файлы на целостность.
%
%\imgw{demo-command-info-3}{h!}{1.0\textwidth}{Команда info, файлы равны}


\section{Тестирование}

\begin{flushleft}
Тестирование метода производилось несколькими способами:
\end{flushleft}

\begin{itemize}
\item юнит тестирование - покрыть основные функции тестами;
\item ручное тестирование.
\end{itemize}

\begin{flushleft}
Для ручного тестирования использовался следующий сценарий.
\end{flushleft}
\begin{enumerate}
\item Cоздать несколько тестовых файлов, которые будут использоваться в процессе резервного копирования.
\item Создать резервные копии через команду \textit{backup}.
\item Восстановить файлы через команду \textit{restore}.
\item Проверить различия файлов (diff) визуально, или с использованием специальных программ, которые позовляют найти отличия в файлах.
\end{enumerate}

Для юнит тестирования будут использоваться встроенные в язык программирования инструменты.  

\section{Выводы}

\begin{flushleft}
В данном разделе:
\end{flushleft}
\begin{itemize}
\item были выбраны средства реализации метода резервного копирования;
\item было разработано программное обеспечение, реализующее разработанный метод;
\item приведен пример использования разработанного метода;
\item осуществлено тестирование метода, для которого использовано два типа тестов --- юнит и ручные тесты.
\end{itemize}




